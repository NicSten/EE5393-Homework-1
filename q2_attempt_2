import math
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# ---------- (Optional) robust numba import for some environments ----------
# This code accelerates the SSA substantially. If you don't want numba, you can
# remove it and keep everything in pure Python (will be much slower).
try:
    import numba
    from numba import njit
except Exception:
    # Some environments have coverage/numba interoperability issues.
    import sys, importlib, coverage
    from typing import Callable, Optional, Any
    coverage.types.Tracer = object
    coverage.types.TShouldTraceFn = Callable[[str, Optional[str]], Any]
    coverage.types.TShouldStartContextFn = Callable[[str, Optional[str]], Any]
    for m in list(sys.modules.keys()):
        if m.startswith("numba"):
            del sys.modules[m]
    numba = importlib.import_module("numba")
    from numba import njit

# -------------------- INPUTS (PASTED UNCHANGED) --------------------
REACTIONS_TEXT = r"""OLRNAP 1 MOI 1 : OLRNAP 1 MOI 1 N 10 : 0.011
RNAP 1 PRE 1 : PRERNAP 1 : 0.01
PRERNAP 1 : RNAP 1 PRE 1 : 1.0
RNAP 1 cI2 1 OR 1 : OR13RNAPcI 1 : 0.02569
OR13RNAPcI 1 : RNAP 1 cI2 1 OR 1 : 1.0
RNAP 1 cI2 1 OR 1 : ORcIRNAP 1 : 0.00967
ORcIRNAP 1 : RNAP 1 cI2 1 OR 1 : 1.0
NUTR4 1 N 1 : NUTRN4 1 : 0.2
NUTRN4 1 : NUTR4 1 N 1 : 1.0
P1 1 cIII 1 : P1cIII 1 : 0.01
P1cIII 1 : P1 1 cIII 1 : 0.01
cI 1 : : 7.0E-4
cI2 1 OR 1 : ORcI 1 : 0.2165
ORcI 1 : cI2 1 OR 1 : 1.0
MOI 1 OR12RNAP 1 NUTRN 1 : MOI 1 OR12RNAP 1 NUTRN 1 cII 10 : 0.014
Basal_error 1 MOI 1 OR3RNAP 1 : Basal_error 1 MOI 1 OR3RNAP 1 cI 10 : 0.0010
ORcIRNAP 1 MOI 1 NUTRN3 1 : ORcIRNAP 1 MOI 1 NUTRN3 1 cII 10 : 0.014
ORCroRNAP 1 NUTRN4 1 MOI 1 : ORCroRNAP 1 NUTRN4 1 MOI 1 cII 10 : 0.014
NUTR 1 N 1 : NUTRN 1 : 0.2
NUTRN 1 : NUTR 1 N 1 : 1.0
Basal_error 1 MOI 1 OR13RNAPcI 1 : Basal_error 1 MOI 1 OR13RNAPcI 1 cI 10 : 0.0010
Cro 2 : Cro2 1 : 0.05
Cro2 1 : Cro 2 : 0.5
Cro2 1 RNAP 1 cI2 1 OR 1 : ORRNAPcICro 1 : 8.0E-5
ORRNAPcICro 1 : Cro2 1 RNAP 1 cI2 1 OR 1 : 1.0
N 1 NUTR3 1 : NUTRN3 1 : 0.2
NUTRN3 1 : N 1 NUTR3 1 : 1.0
OLRNAP 1 MOI 1 NUTL 1 : cIII 10 OLRNAP 1 MOI 1 NUTL 1 : 0.0022
Cro2 2 OL 1 : OL2Cro 1 : 0.0158
OL2Cro 1 : Cro2 2 OL 1 : 1.0
P2cII 1 : P2 1 : 0.6
NUTR 1 MOI 1 OR12RNAP 1 : NUTR 1 MOI 1 OR12RNAP 1 cII 10 : 0.0070
Cro2 2 RNAP 1 OR 1 : ORRNAP2Cro 1 : 2.6E-4
ORRNAP2Cro 1 : Cro2 2 RNAP 1 OR 1 : 1.0
RNAP 1 OR 1 : OR12RNAP 1 : 0.69422
OR12RNAP 1 : RNAP 1 OR 1 : 1.0
P2cIII 1 : P2 1 : 0.0010
cI2 1 OL 1 : OLcI 1 : 0.2025
OLcI 1 : cI2 1 OL 1 : 1.0
P1 1 cII 1 : P1cII 1 : 0.0002
P1cII 1 : P1 1 cII 1 : 0.05
N 1 : : 0.00231
PRE 1 cII 1 : PREcII 1 : 0.00726
PREcII 1 : PRE 1 cII 1 : 1.0
Cro2 1 cI2 1 OR 1 : ORCrocI 1 : 0.1779
ORCrocI 1 : Cro2 1 cI2 1 OR 1 : 1.0
P1cII 1 : P1 1 : 0.6
OR2RNAP 1 MOI 1 NUTR2 1 : OR2RNAP 1 MOI 1 NUTR2 1 cII 10 : 0.0070
MOI 1 PREcIIRNAP 1 : MOI 1 cI 10 PREcIIRNAP 1 : 0.015
ORCroRNAP 1 MOI 1 : Cro 10 ORCroRNAP 1 MOI 1 : 0.014
RNAP 1 cI2 1 OR 1 : ORRNAPcI 1 : 0.0019
ORRNAPcI 1 : RNAP 1 cI2 1 OR 1 : 1.0
cI 2 : cI2 1 : 0.05
cI2 1 : cI 2 : 0.5
ORcIRNAP 1 MOI 1 NUTR3 1 : ORcIRNAP 1 MOI 1 NUTR3 1 cII 10 : 0.0070
ORRNAPcICro 1 MOI 1 Kd 1 : ORRNAPcICro 1 MOI 1 cI 10 Kd 1 : 0.011
cI2 3 OR 1 : OR3cI 1 : 8.1E-4
OR3cI 1 : cI2 3 OR 1 : 1.0
Cro2 2 OR 1 : OR2Cro 1 : 0.03342
OR2Cro 1 : Cro2 2 OR 1 : 1.0
cI2 2 OL 1 : OL2cI 1 : 0.058
OL2cI 1 : cI2 2 OL 1 : 1.0
OLRNAP 1 NUTLN 1 MOI 1 : cIII 10 OLRNAP 1 NUTLN 1 MOI 1 : 0.011
MOI 1 ORRNAP2cI 1 Kd 1 : MOI 1 ORRNAP2cI 1 cI 10 Kd 1 : 0.011
Cro2 1 RNAP 1 OR 1 : ORRNAPCro 1 : 0.01186
ORRNAPCro 1 : Cro2 1 RNAP 1 OR 1 : 1.0
ORcIRNAP 1 MOI 1 : ORcIRNAP 1 Cro 10 MOI 1 : 0.014
Cro2 1 cI2 1 OL 1 : OLcICro 1 : 0.014
OLcICro 1 : Cro2 1 cI2 1 OL 1 : 1.0
MOI 1 PRERNAP 1 : MOI 1 cI 10 PRERNAP 1 : 4.0E-5
N 1 NUTL 1 : NUTLN 1 : 0.2
NUTLN 1 : N 1 NUTL 1 : 1.0
NUTR4 1 ORCroRNAP 1 MOI 1 : NUTR4 1 ORCroRNAP 1 MOI 1 cII 10 : 0.0070
Basal_error 1 MOI 1 ORRNAPCro 1 : Basal_error 1 MOI 1 cI 10 ORRNAPCro 1 : 0.0010
RNAP 1 OR 1 : OR3RNAP 1 : 0.1362
OR3RNAP 1 : RNAP 1 OR 1 : 1.0
Cro2 1 cI2 2 OR 1 : ORCro2cI 1 : 0.02133
ORCro2cI 1 : Cro2 1 cI2 2 OR 1 : 1.0
Cro2 1 RNAP 1 OR 1 : ORCroRNAP 1 : 0.25123
ORCroRNAP 1 : Cro2 1 RNAP 1 OR 1 : 1.0
RNAP 1 PRE 1 cII 1 : PREcIIRNAP 1 : 0.00161
PREcIIRNAP 1 : RNAP 1 PRE 1 cII 1 : 1.0
Cro2 1 PRE 1 : PRECro 1 : 1.0E-5
PRECro 1 : Cro2 1 PRE 1 : 0.1
Basal_error 1 MOI 1 ORRNAP2CrocI 1 : Basal_error 1 MOI 1 ORRNAP2CrocI 1 cI 10 : 0.0010
Cro 1 : : 0.0025
P2 1 cII 1 : P2cII 1 : 2.5E-4
P2cII 1 : P2 1 cII 1 : 0.065
cI2 2 OR 1 : OR2cI 1 : 0.06568
OR2cI 1 : cI2 2 OR 1 : 1.0
P1cIII 1 : P1 1 : 0.001
RNAP 2 OR 1 : OR2RNAP 1 : 0.09455
OR2RNAP 1 : RNAP 2 OR 1 : 1.0
Cro2 2 cI2 1 OR 1 : OR2CrocI 1 : 0.00322
OR2CrocI 1 : Cro2 2 cI2 1 OR 1 : 1.0
OR2RNAP 1 Basal_error 1 MOI 1 : OR2RNAP 1 Basal_error 1 MOI 1 cI 10 : 0.0010
cIII 1 P2 1 : P2cIII 1 : 0.01
P2cIII 1 : cIII 1 P2 1 : 0.01
Cro2 1 cI2 1 OR 1 : ORCrocI 1 : 0.1779
ORCrocI 1 : Cro2 1 cI2 1 OR 1 : 1.0
Cro2 1 OR 1 : ORCro 1 : 0.449
ORCro 1 : Cro2 1 OR 1 : 1.0
Cro2 3 OR 1 : OR3Cro 1 : 6.9E-4
OR3Cro 1 : Cro2 3 OR 1 : 1.0
Cro2 1 OL 1 : OLCro 1 : 0.4132
OLCro 1 : Cro2 1 OL 1 : 1.0
ORRNAP2Cro 1 Basal_error 1 MOI 1 : ORRNAP2Cro 1 Basal_error 1 MOI 1 cI 10 : 0.0010
Cro2 1 RNAP 1 cI2 1 OR 1 : ORRNAP2CrocI 1 : 0.00112
ORRNAP2CrocI 1 : Cro2 1 RNAP 1 cI2 1 OR 1 : 1.0
RNAP 1 cI2 2 OR 1 : ORRNAP2cI 1 : 0.0079
ORRNAP2cI 1 : RNAP 1 cI2 2 OR 1 : 1.0
N 1 NUTR2 1 : NUTRN2 1 : 0.2
NUTRN2 1 : N 1 NUTR2 1 : 1.0
MOI 1 OR12RNAP 1 : Cro 10 MOI 1 OR12RNAP 1 : 0.014
OR2RNAP 1 MOI 1 NUTRN2 1 : OR2RNAP 1 MOI 1 NUTRN2 1 cII 10 : 0.014
OR2RNAP 1 MOI 1 : Cro 10 OR2RNAP 1 MOI 1 : 0.014
MOI 1 ORRNAPcI 1 Kd 1 : ORRNAPcI 1 MOI 1 cI 10 Kd 1 : 0.011
RNAP 1 OL 1 : OLRNAP 1 : 0.6942
OLRNAP 1 : RNAP 1 OL 1 : 1.0
"""

INITIAL_TEXT = r"""cI2 0 GE 145
Cro2 0 GE 55
MOI 6 N
P1cIII 0 N
ORCrocI 0 N
NUTRN4 0 N
OR13RNAPcI 0 N
Kd 1 N
ORCro2cI 0 N
N 0 N
ORcI 0 N
PRECro 0 N
OR 1 N
ORCro 0 N
PRE 1 N
ORRNAP2CrocI 0 N
NUTRN2 0 N
OLCro 0 N
P2cIII 0 N
ORRNAPcICro 0 N
OR2RNAP 0 N
P2 100 N
OR2cI 0 N
OR3cI 0 N
PREcIIRNAP 0 N
ORRNAPCro 0 N
NUTR4 1 N
NUTL 1 N
OR12RNAP 0 N
OLcI 0 N
ORCroRNAP 0 N
Cro 0 N
ORRNAP2Cro 0 N
NUTRN3 0 N
Basal_error 1 N
ORcIRNAP 0 N
cIII 0 N
P1cII 0 N
PREcII 0 N
OLcICro 0 N
OL 1 N
OR3RNAP 0 N
OL2Cro 0 N
cI 0 N
OR2Cro 0 N
ORRNAP2cI 0 N
OL2cI 0 N
NUTLN 0 N
OR2CrocI 0 N
P1 40 N
RNAP 30 N
NUTR 1 N
NUTR3 1 N
OLRNAP 0 N
PRERNAP 0 N
cII 0 N
P2cII 0 N
ORRNAPcI 0 N
OR3Cro 0 N
NUTR2 1 N
NUTRN 0 N
"""

# -------------------- PARSING --------------------
def parse_side(side: str) -> dict[str, int]:
    side = side.strip()
    if side == "":
        return {}
    toks = side.split()
    if len(toks) % 2 != 0:
        raise ValueError(f"Odd number of tokens in side: {side!r}")
    out = {}
    for i in range(0, len(toks), 2):
        sp = toks[i]
        sto = int(toks[i + 1])
        out[sp] = out.get(sp, 0) + sto
    return out

def parse_model(reactions_text: str, initial_text: str):
    rxn_lines = [ln.strip() for ln in reactions_text.strip().splitlines() if ln.strip()]
    react_list, prod_list, k_list = [], [], []
    species = set()
    for ln in rxn_lines:
        r, p, k = [x.strip() for x in ln.split(":")]
        rd = parse_side(r)
        pd_ = parse_side(p)
        kf = float(k)
        react_list.append(rd)
        prod_list.append(pd_)
        k_list.append(kf)
        species.update(rd.keys())
        species.update(pd_.keys())

    init = {}
    for ln in initial_text.strip().splitlines():
        toks = ln.split()
        sp = toks[0]
        ct = int(toks[1])
        init[sp] = ct
        species.add(sp)

    species = sorted(species)
    sp_idx = {sp: i for i, sp in enumerate(species)}

    x0 = np.zeros(len(species), dtype=np.int64)
    for sp, ct in init.items():
        x0[sp_idx[sp]] = ct

    # Flatten reactants and deltas for speed
    M = len(k_list)
    r_ptr = np.zeros(M + 1, dtype=np.int32)
    d_ptr = np.zeros(M + 1, dtype=np.int32)
    r_idx_flat, r_sto_flat = [], []
    d_idx_flat, d_val_flat = [], []
    for j in range(M):
        rd = react_list[j]
        pd_ = prod_list[j]
        for sp, sto in rd.items():
            r_idx_flat.append(sp_idx[sp])
            r_sto_flat.append(sto)
        r_ptr[j + 1] = len(r_idx_flat)

        delta = {}
        for sp, sto in pd_.items():
            ii = sp_idx[sp]
            delta[ii] = delta.get(ii, 0) + sto
        for sp, sto in rd.items():
            ii = sp_idx[sp]
            delta[ii] = delta.get(ii, 0) - sto
        for ii, dv in delta.items():
            if dv != 0:
                d_idx_flat.append(ii)
                d_val_flat.append(dv)
        d_ptr[j + 1] = len(d_idx_flat)

    r_idx_flat = np.array(r_idx_flat, dtype=np.int32)
    r_sto_flat = np.array(r_sto_flat, dtype=np.int32)
    d_idx_flat = np.array(d_idx_flat, dtype=np.int32)
    d_val_flat = np.array(d_val_flat, dtype=np.int32)
    k_arr = np.array(k_list, dtype=np.float64)

    # Dependency: reactions whose propensities depend on a species
    dep = [[] for _ in range(len(species))]
    for j in range(M):
        seen = set()
        for pos in range(r_ptr[j], r_ptr[j + 1]):
            idx = int(r_idx_flat[pos])
            if idx not in seen:
                dep[idx].append(j)
                seen.add(idx)

    # For each reaction j, precompute which reactionsâ€™ propensities need recomputing after j fires
    affected = []
    for j in range(M):
        changed = set(int(d_idx_flat[pos]) for pos in range(d_ptr[j], d_ptr[j + 1]))
        aff = set()
        for sp in changed:
            for rj in dep[sp]:
                aff.add(rj)
        affected.append(tuple(sorted(aff)))

    # Flatten affected lists
    aff_ptr = np.zeros(M + 1, dtype=np.int32)
    aff_idx_flat = []
    for j in range(M):
        for jj in affected[j]:
            aff_idx_flat.append(jj)
        aff_ptr[j + 1] = len(aff_idx_flat)
    aff_idx_flat = np.array(aff_idx_flat, dtype=np.int32)

    return species, sp_idx, x0, k_arr, r_ptr, r_idx_flat, r_sto_flat, d_ptr, d_idx_flat, d_val_flat, aff_ptr, aff_idx_flat

# -------------------- SSA (Gillespie Direct) --------------------
@njit
def comb_num(n, s):
    # combinatorial propensity term C(n, s)
    if n < s:
        return 0.0
    if s == 1:
        return float(n)
    elif s == 2:
        return 0.5 * float(n * (n - 1))
    elif s == 3:
        return (1.0 / 6.0) * float(n * (n - 1) * (n - 2))
    else:
        c = 1.0
        for i in range(1, s + 1):
            c *= (n - (s - i)) / i
        return c

@njit
def propensity_num(j, x, k_arr, r_ptr, r_idx_flat, r_sto_flat):
    a = k_arr[j]
    rs = r_ptr[j]
    re = r_ptr[j + 1]
    for pos in range(rs, re):
        idx = r_idx_flat[pos]
        sto = r_sto_flat[pos]
        c = comb_num(x[idx], sto)
        if c == 0.0:
            return 0.0
        a *= c
    return a

@njit
def simulate_counts_for_moi(
    ntraj, moi, Tmax, seed,
    x0, k_arr,
    r_ptr, r_idx_flat, r_sto_flat,
    d_ptr, d_idx_flat, d_val_flat,
    aff_ptr, aff_idx_flat,
    MOI_idx, cI2_idx, Cro2_idx,
    cI2_thr, Cro2_thr
):
    # outcomes: 0 stealth, 1 hijack, 2 undecided, 3 tie
    np.random.seed(seed)
    M = len(k_arr)
    counts = np.zeros(4, dtype=np.int64)

    for tr in range(ntraj):
        x = x0.copy()
        x[MOI_idx] = moi

        a = np.empty(M, dtype=np.float64)
        total = 0.0
        for j in range(M):
            aj = propensity_num(j, x, k_arr, r_ptr, r_idx_flat, r_sto_flat)
            a[j] = aj
            total += aj

        t = 0.0
        decided = False

        while t < Tmax:
            if total <= 0.0 or not np.isfinite(total):
                break

            u1 = np.random.random()
            if u1 <= 0.0:
                u1 = np.nextafter(0.0, 1.0)
            t += -math.log(u1) / total

            r = np.random.random() * total
            s = 0.0
            jsel = 0
            for j in range(M):
                s += a[j]
                if s > r:
                    jsel = j
                    break

            prev_stealth = x[cI2_idx] > cI2_thr
            prev_hijack  = x[Cro2_idx] > Cro2_thr

            # state update
            ds = d_ptr[jsel]
            de = d_ptr[jsel + 1]
            for pos in range(ds, de):
                idx = d_idx_flat[pos]
                x[idx] += d_val_flat[pos]
                if x[idx] < 0:
                    x[idx] = 0

            new_stealth = x[cI2_idx] > cI2_thr
            new_hijack  = x[Cro2_idx] > Cro2_thr
            stealth_cross = (not prev_stealth) and new_stealth
            hijack_cross  = (not prev_hijack) and new_hijack

            if stealth_cross or hijack_cross:
                if stealth_cross and hijack_cross:
                    counts[3] += 1
                elif stealth_cross:
                    counts[0] += 1
                else:
                    counts[1] += 1
                decided = True
                break

            # update only propensities that depend on species changed by this reaction
            aps = aff_ptr[jsel]
            ape = aff_ptr[jsel + 1]
            for pos in range(aps, ape):
                jj = aff_idx_flat[pos]
                newa = propensity_num(jj, x, k_arr, r_ptr, r_idx_flat, r_sto_flat)
                delta = newa - a[jj]
                if delta != 0.0:
                    a[jj] = newa
                    total += delta

        if not decided:
            counts[2] += 1

    return counts

def wilson_ci(k, n, z=1.96):
    p = k / n
    denom = 1.0 + z*z/n
    center = (p + z*z/(2*n)) / denom
    half = (z * math.sqrt((p*(1-p) + z*z/(4*n)) / n)) / denom
    return center - half, center + half

def main():
    # knobs
    NTRAJ = 1500         # increase to 5000-20000 if you have time/compute
    TMAX  = 3000.0
    SEED0 = 1000

    species, sp_idx, x0, k_arr, r_ptr, r_idx_flat, r_sto_flat, d_ptr, d_idx_flat, d_val_flat, aff_ptr, aff_idx_flat = parse_model(
        REACTIONS_TEXT, INITIAL_TEXT
    )

    cI2_idx = sp_idx["cI2"]
    Cro2_idx = sp_idx["Cro2"]
    MOI_idx = sp_idx["MOI"]

    rows = []
    for moi in range(1, 11):
        counts = simulate_counts_for_moi(
            NTRAJ, moi, TMAX, SEED0 + moi,
            x0, k_arr,
            r_ptr, r_idx_flat, r_sto_flat,
            d_ptr, d_idx_flat, d_val_flat,
            aff_ptr, aff_idx_flat,
            MOI_idx, cI2_idx, Cro2_idx,
            145, 55
        )
        stealth, hijack, undec, tie = (int(counts[0]), int(counts[1]), int(counts[2]), int(counts[3]))
        ps, ph, pu, pt = stealth/NTRAJ, hijack/NTRAJ, undec/NTRAJ, tie/NTRAJ
        cis = wilson_ci(stealth, NTRAJ)
        cih = wilson_ci(hijack, NTRAJ)
        rows.append({
            "MOI": moi,
            "P(stealth)": ps, "stealth_CI_low": cis[0], "stealth_CI_high": cis[1],
            "P(hijack)": ph,  "hijack_CI_low": cih[0], "hijack_CI_high": cih[1],
            "P(undecided)": pu,
            "P(tie)": pt
        })

    df = pd.DataFrame(rows)
    print(df.to_string(index=False))

    df.to_csv("lambda_ssa_results.csv", index=False)

    plt.figure()
    plt.plot(df["MOI"], df["P(stealth)"], marker="o", label="P(stealth) (cI2>145)")
    plt.plot(df["MOI"], df["P(hijack)"], marker="o", label="P(hijack) (Cro2>55)")
    plt.plot(df["MOI"], df["P(undecided)"], marker="o", label="P(undecided)")
    plt.xlabel("MOI (initial count)")
    plt.ylabel("Probability")
    plt.ylim(0, 1)
    plt.grid(True, alpha=0.3)
    plt.legend()
    plt.tight_layout()
    plt.savefig("lambda_ssa_probs.png", dpi=200)
    plt.show()

if __name__ == "__main__":
    main()